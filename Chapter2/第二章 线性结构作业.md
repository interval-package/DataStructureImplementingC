# 第二章 线性结构作业

项目源码可见：https://github.com/interval-package/DataStructureImplementingC.git

## 1.头指针，头结点，首元素

1. 头指针：是一个指针，指向表中的第一个结点元素。链表中第一个结点的存储位置叫做头指针。
2. 头结点：[头结点](http://www.nowamagic.net/librarys/veda/tag/头结点)是为了操作的统一与方便而设立的，是我们设立的辅助存储结点。一般来说放在第一个元素结点之前，其数据域一般无意义（当然有些情况下也可存放链表的长度、用做监视哨等等）。
3. 受元素结点：指的是一个有实际元素意义的结点。一般是头结点后面的结点。

![img](http://images.cnitblog.com/blog/277239/201308/24055201-91e1a3475c5a45a48e680e7c01184ca1.jpg)

## 2.顺序表，链表的特征与使用选择

### （1）顺序表：

- 特征：较为静态的存储特征，能够较为快速的进行随机存取，建立好映射关系可以快速查找。但是因为其静态特征，对于插入删除其复杂度较高。
- 使用选择：对于要进行频繁查找、修改内容、不进行大量的插删的业务情况可以使用。
- 应用：例如存储按序号排序的信息，电话通讯录等情况。

### （2）链表：

- 特征：动态性强，对于存储空间具有随机性，能够快速地在链表的中间进行插入与删除。但是对于某一元素的访问会需要遍历，较慢。
- 使用选择：对于要进行频繁进行内部插入删除的情况可以使用。
- 应用：例如，存储一个需要进行频繁修改的顺序表。

## 3.算法设计：反转链表

### （1）算法：

新建一个临时头节点，然后对原链表进行头删，然后对新表进行头插，最后把临时结点的后继赋值给原头结点。

### （2）代码：

```c
void Reverse_lList(linkedList p0){
//    我们认为是有头结点的，p0为头节点指针

//    设置新的头节点
    lNode *temp, newHead;
    newHead.next = NULL;

    while (p0->next){
//        从原来的链表上摘下结点
        temp = p0->next;
        p0->next = temp->next;
//  把摘下结点头插到新的链表上
        temp->next = newHead.next;
        newHead.next = temp;
    }
    p0->next = newHead.next;
}
```

## 4.算法设计：有序表插入

### （1）算法：

顺序表：进行二分法比对，取区间中点与元素大小进行比对，然后更新区间。

链表：两个指针，一个保存前一位，一个保存现在位置，向后遍历，如果发现当前结点大于tar，则插入。

### （2）代码：

#### 1.顺序表

```c
// insert x question
void InsertInto_OrderedList(SequentialList *la, ELEMENT_TYPE tar){
//    我们认为la已经是一个，排好序，从小到大的列表了
    int upBound =  la->elementCount, lowBound = 1, temp = 1;
    while(upBound != lowBound && la->elementArray[temp]!=tar){
        temp = (upBound+lowBound)/2;
        if(la->elementArray[temp]<tar){
            lowBound = temp;
        } else{
            upBound = temp;
        }
    }
    sqListInsert(la,temp,tar);
}
```

#### 2.链表

```c
void Insert_X_Linked(linkedList p0,ELEMENT_TYPE tar){
    linkedList temp;
    do{
        temp = p0;
        p0 = p0->next;
    }while(p0 && p0->data>tar);
    lListInsertRear(temp,tar);
};
```

## 5.算法设计：循环链表右删

### （1）算法：

进行遍历，到达链表尾部进行后删。

### （2）代码：

```c
void right_Delete(clList *cll){
    if((*cll)->next == *cll){
        return;
    }
    clList temp = *cll;
    while(temp->next!=(*cll)){
        temp = temp->next;
    }
    temp->next = (*cll)->next;
    free(*cll);
    *cll = temp;
}
```

## 6.算法设计：双向链表查找（第一个）删除

### （1）算法：

循环更新，然后查找。

### （2）代码：

```c
void DuListFirstXDelete(DuList l, ELEMENT_TYPE tar){
    do{
        l = l->rear;
    } while (l && l->data != tar);
    if(l){
        l->prior->rear = l->rear;
        if(l->rear)l->rear->prior = l->prior;
        free(l);
    }
}
```